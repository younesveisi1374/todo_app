[
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "pythoncom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pythoncom",
        "description": "pythoncom",
        "detail": "pythoncom",
        "documentation": {}
    },
    {
        "label": "win32api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32api",
        "description": "win32api",
        "detail": "win32api",
        "documentation": {}
    },
    {
        "label": "win32con",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32con",
        "description": "win32con",
        "detail": "win32con",
        "documentation": {}
    },
    {
        "label": "win32file",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32file",
        "description": "win32file",
        "detail": "win32file",
        "documentation": {}
    },
    {
        "label": "wmi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wmi",
        "description": "wmi",
        "detail": "wmi",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "cgi",
        "description": "cgi",
        "isExtraImport": true,
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "make_server",
        "importPath": "wsgiref.simple_server",
        "description": "wsgiref.simple_server",
        "isExtraImport": true,
        "detail": "wsgiref.simple_server",
        "documentation": {}
    },
    {
        "label": "request_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "application_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "shift_path_info",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "steps",
        "importPath": "gpt_engineer",
        "description": "gpt_engineer",
        "isExtraImport": true,
        "detail": "gpt_engineer",
        "documentation": {}
    },
    {
        "label": "steps",
        "importPath": "gpt_engineer",
        "description": "gpt_engineer",
        "isExtraImport": true,
        "detail": "gpt_engineer",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DB",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DB",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DB",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DB",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "importPath": "gpt_engineer.db",
        "description": "gpt_engineer.db",
        "isExtraImport": true,
        "detail": "gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "Step",
        "importPath": "gpt_engineer.domain",
        "description": "gpt_engineer.domain",
        "isExtraImport": true,
        "detail": "gpt_engineer.domain",
        "documentation": {}
    },
    {
        "label": "Step",
        "importPath": "gpt_engineer.domain",
        "description": "gpt_engineer.domain",
        "isExtraImport": true,
        "detail": "gpt_engineer.domain",
        "documentation": {}
    },
    {
        "label": "Learning",
        "importPath": "gpt_engineer.learning",
        "description": "gpt_engineer.learning",
        "isExtraImport": true,
        "detail": "gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "extract_learning",
        "importPath": "gpt_engineer.learning",
        "description": "gpt_engineer.learning",
        "isExtraImport": true,
        "detail": "gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "human_input",
        "importPath": "gpt_engineer.learning",
        "description": "gpt_engineer.learning",
        "isExtraImport": true,
        "detail": "gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "extract_learning",
        "importPath": "gpt_engineer.learning",
        "description": "gpt_engineer.learning",
        "isExtraImport": true,
        "detail": "gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "AI",
        "importPath": "gpt_engineer.ai",
        "description": "gpt_engineer.ai",
        "isExtraImport": true,
        "detail": "gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "AI",
        "importPath": "gpt_engineer.ai",
        "description": "gpt_engineer.ai",
        "isExtraImport": true,
        "detail": "gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "fallback_model",
        "importPath": "gpt_engineer.ai",
        "description": "gpt_engineer.ai",
        "isExtraImport": true,
        "detail": "gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "AI",
        "importPath": "gpt_engineer.ai",
        "description": "gpt_engineer.ai",
        "isExtraImport": true,
        "detail": "gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "AI",
        "importPath": "gpt_engineer.ai",
        "description": "gpt_engineer.ai",
        "isExtraImport": true,
        "detail": "gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "AI",
        "importPath": "gpt_engineer.ai",
        "description": "gpt_engineer.ai",
        "isExtraImport": true,
        "detail": "gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "dataclass_json",
        "importPath": "dataclasses_json",
        "description": "dataclasses_json",
        "isExtraImport": true,
        "detail": "dataclasses_json",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "typer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typer",
        "description": "typer",
        "detail": "typer",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "typer",
        "description": "typer",
        "isExtraImport": true,
        "detail": "typer",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "typer",
        "description": "typer",
        "isExtraImport": true,
        "detail": "typer",
        "documentation": {}
    },
    {
        "label": "collect_learnings",
        "importPath": "gpt_engineer.collect",
        "description": "gpt_engineer.collect",
        "isExtraImport": true,
        "detail": "gpt_engineer.collect",
        "documentation": {}
    },
    {
        "label": "collect_learnings",
        "importPath": "gpt_engineer.collect",
        "description": "gpt_engineer.collect",
        "isExtraImport": true,
        "detail": "gpt_engineer.collect",
        "documentation": {}
    },
    {
        "label": "steps_file_hash",
        "importPath": "gpt_engineer.collect",
        "description": "gpt_engineer.collect",
        "isExtraImport": true,
        "detail": "gpt_engineer.collect",
        "documentation": {}
    },
    {
        "label": "STEPS",
        "importPath": "gpt_engineer.steps",
        "description": "gpt_engineer.steps",
        "isExtraImport": true,
        "detail": "gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "gen_code",
        "importPath": "gpt_engineer.steps",
        "description": "gpt_engineer.steps",
        "isExtraImport": true,
        "detail": "gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "to_files",
        "importPath": "gpt_engineer.chat_to_files",
        "description": "gpt_engineer.chat_to_files",
        "isExtraImport": true,
        "detail": "gpt_engineer.chat_to_files",
        "documentation": {}
    },
    {
        "label": "to_files",
        "importPath": "gpt_engineer.chat_to_files",
        "description": "gpt_engineer.chat_to_files",
        "isExtraImport": true,
        "detail": "gpt_engineer.chat_to_files",
        "documentation": {}
    },
    {
        "label": "to_files",
        "importPath": "gpt_engineer.chat_to_files",
        "description": "gpt_engineer.chat_to_files",
        "isExtraImport": true,
        "detail": "gpt_engineer.chat_to_files",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "rudderstack.analytics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rudderstack.analytics",
        "description": "rudderstack.analytics",
        "detail": "rudderstack.analytics",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "django.apps",
        "description": "django.apps",
        "isExtraImport": true,
        "detail": "django.apps",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "django.test",
        "description": "django.test",
        "isExtraImport": true,
        "detail": "django.test",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "get_object_or_404",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "get_asgi_application",
        "importPath": "django.core.asgi",
        "description": "django.core.asgi",
        "isExtraImport": true,
        "detail": "django.core.asgi",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "views",
        "importPath": "todo_app",
        "description": "todo_app",
        "isExtraImport": true,
        "detail": "todo_app",
        "documentation": {}
    },
    {
        "label": "get_wsgi_application",
        "importPath": "django.core.wsgi",
        "description": "django.core.wsgi",
        "isExtraImport": true,
        "detail": "django.core.wsgi",
        "documentation": {}
    },
    {
        "label": "importlib_load_entry_point",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.cowsay-script",
        "description": "todo_project.env.Scripts.cowsay-script",
        "peekOfCode": "def importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')\n    matches = (\n        entry_point\n        for entry_point in distribution(dist_name).entry_points\n        if entry_point.group == group and entry_point.name == name\n    )\n    return next(matches).load()\nglobals().setdefault('load_entry_point', importlib_load_entry_point)\nif __name__ == '__main__':",
        "detail": "todo_project.env.Scripts.cowsay-script",
        "documentation": {}
    },
    {
        "label": "__requires__",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.cowsay-script",
        "description": "todo_project.env.Scripts.cowsay-script",
        "peekOfCode": "__requires__ = 'cowsay==5.0'\ntry:\n    from importlib.metadata import distribution\nexcept ImportError:\n    try:\n        from importlib_metadata import distribution\n    except ImportError:\n        from pkg_resources import load_entry_point\ndef importlib_load_entry_point(spec, group, name):\n    dist_name, _, _ = spec.partition('==')",
        "detail": "todo_project.env.Scripts.cowsay-script",
        "documentation": {}
    },
    {
        "label": "version_pattern",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.publish",
        "description": "todo_project.env.Scripts.publish",
        "peekOfCode": "version_pattern = r'\\d\\.\\d\\.\\d'\nparser = argparse.ArgumentParser()\nparser.add_argument('version', help='a SEMVER string X.Y.Z')\nargs = parser.parse_args()\nif not re.match(version_pattern, args.version):\n    print('argument must be SEMVER string in format X.Y.Z')\nelse:\n    with open('setup.py') as fp:\n        old_setupfile = fp.read()\n    new_setupfile = re.sub(f\"version='{version_pattern}'\",",
        "detail": "todo_project.env.Scripts.publish",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.publish",
        "description": "todo_project.env.Scripts.publish",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument('version', help='a SEMVER string X.Y.Z')\nargs = parser.parse_args()\nif not re.match(version_pattern, args.version):\n    print('argument must be SEMVER string in format X.Y.Z')\nelse:\n    with open('setup.py') as fp:\n        old_setupfile = fp.read()\n    new_setupfile = re.sub(f\"version='{version_pattern}'\",\n                           f\"version='{args.version}'\", old_setupfile)",
        "detail": "todo_project.env.Scripts.publish",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.publish",
        "description": "todo_project.env.Scripts.publish",
        "peekOfCode": "args = parser.parse_args()\nif not re.match(version_pattern, args.version):\n    print('argument must be SEMVER string in format X.Y.Z')\nelse:\n    with open('setup.py') as fp:\n        old_setupfile = fp.read()\n    new_setupfile = re.sub(f\"version='{version_pattern}'\",\n                           f\"version='{args.version}'\", old_setupfile)\n    with open('setup.py', 'w') as fp:\n        print(new_setupfile, file=fp)",
        "detail": "todo_project.env.Scripts.publish",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except IOError:\n                pass\n        tee_f.write(what)",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info[0],\n        sys.version_info[1],\n        suffix,",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(\"-> %s\\\\%s[%s]=%r\" % (root_key_name, key_name, value_name, value))\n        finally:",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(\"-> DELETE %s\\\\%s[%s]\" % (root_key_name, key_name, value_name))\n        finally:",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n        like file_created to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(\"Failed to unregister COM objects: %s\" % (why,))\n    try:",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location):\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError('Path \"{}\" does not exist!'.format(location))\n    return location\ndef main():\n    import argparse\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    import argparse\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python pywin32_postinstall.py -install\n    If you installed pywin32 via a .exe installer, this should be run\n    automatically after installation, but if it fails you can run it again.\n    If you installed pywin32 via PIP, you almost certainly need to run this to",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(os.path.join(tempfile.gettempdir(), \"pywin32_postinstall.log\"), \"w\")\nclass Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except IOError:\n                pass",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to Python23\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to Python23\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created\n    is_bdist_wininst = True",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_postinstall",
        "description": "todo_project.env.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to Python23\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created\n    is_bdist_wininst = True\nexcept NameError:",
        "detail": "todo_project.env.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_testall",
        "description": "todo_project.env.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(\"*** Test script '%s' exited with %s\" % (script, result.returncode))\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": "todo_project.env.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_testall",
        "description": "todo_project.env.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": "todo_project.env.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.pywin32_testall",
        "description": "todo_project.env.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [this_dir] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": "todo_project.env.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "this_dir",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_testall",
        "description": "todo_project.env.Scripts.pywin32_testall",
        "peekOfCode": "this_dir = os.path.dirname(__file__)\nsite_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)",
        "detail": "todo_project.env.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_testall",
        "description": "todo_project.env.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.",
        "detail": "todo_project.env.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.pywin32_testall",
        "description": "todo_project.env.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": "todo_project.env.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "TestBasicConnections",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:\n            warnings.warn(\"Skipping test_remote_connection\")",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestThreadedConnection",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestThreadedConnection(unittest.TestCase):\n    def test_initialised_thread(self):\n        \"\"\"A WMI connection in a thread which has been initialised for COM\n        should succeed.\n        \"\"\"\n        def f(q):\n            pythoncom.CoInitialize()\n            try:\n                try:\n                    wmi.WMI()",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMoniker",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestMoniker(unittest.TestCase):\n    def test_moniker(self):\n        \"\"\"Look at all possible options for moniker construction and pass\n        them through to a WMI connector\n        \"\"\"\n        for computer in COMPUTERS:\n            if computer in (None, \".\"):\n                local_authorities = [None]\n            else:\n                local_authorities = AUTHORITIES",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestFunctions",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestFunctions(unittest.TestCase):\n    times = [\n       ((2000, 1, 1), \"20000101******.******+***\"),\n       ((2000, 1, 1, 10, 0, 0), \"20000101100000.******+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100), \"20000101100000.000100+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100, \"GMT\"), \"20000101100000.000100+GMT\")\n    ]\n    def test_signed_to_unsigned(self):\n        tests = [\n           (0, 0),",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWMI",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestWMI(unittest.TestCase):\n    def setUp(self):\n        self.connection = wmi.WMI(namespace=\"root/cimv2\", find_classes=False)\n        self.logical_disks = set(self.connection.Win32_LogicalDisk())\nclass TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestNamespace",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):\n        self.assert_(set([\"Win32_LogicalDisk\", \"Win32_MappedLogicalDisk\"]) <= set(self.connection.subclasses_of(\"CIM_LogicalDevice\", \"Win32_.*Disk\")))\n    def test_instances(self):\n        self.assertEquals(self.logical_disks, set(self.connection.instances(\"Win32_LogicalDisk\")))\n    def test_new(self):",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestClass",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestClass(TestWMI):\n    def test_class_from_namespace(self):\n        self.assert_(self.connection.Win32_ComputerSystem._namespace is self.connection)\n    def test_class_without_namespace(self):\n        wmi_class = wmi.GetObject(\"winmgmts:Win32_ComputerSystem\")\n        self.assert_(wmi._wmi_class(None, wmi_class)._namespace)\n    def test_query(self):\n        self.assertEquals(\n            set(self.connection.Win32_ComputerSystem.query()),\n            set(self.connection.query(\"SELECT * FROM Win32_ComputerSystem\"))",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWatcher",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestWatcher(TestWMI):\n    def new_letter(self):\n        return \\\n            set(\"%s:\" % chr(i) for i in range(ord('A'), 1 + ord('Z'))).\\\n            difference(d.DeviceID for d in self.connection.Win32_LogicalDisk()).\\\n            pop()\n    @staticmethod\n    def create(new_letter):\n        #~ print(\"about to create drive with letter\", new_letter)\n        here = os.path.dirname(os.path.abspath(__file__))",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMethods",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestMethods(TestWMI):\n    def test_exists(self):\n        \"Check that a well-known method is available by attribute\"\n        self.assert_(self.connection.Win32_Process.Create)\n    def test_params(self):\n        \"Check that the names and arrayness of params are picked up when not arrays\"\n        self.assertEquals(\n            [(n, False) for n in [\"CommandLine\", \"CurrentDirectory\", \"ProcessStartupInformation\"]],\n            self.connection.Win32_Process.Create.in_parameter_names\n        )",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestProperties",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestProperties(TestWMI):\n    def test_access(self):\n        \"Check that all properties are available as attributes\"\n        for d in self.logical_disks:\n            break\n        for p in d.ole_object.Properties_:\n            self.assertEqual(p.Value, getattr(d, p.Name))\n    def test_attribute_passthrough(self):\n        \"Check that unknown attributes are passed through to the underlying object\"\n        for d in self.logical_disks:",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstances",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestInstances(TestWMI):\n    def test_hashable(self):\n        \"Ensure instances are hashable so can be used in a set/dict\"\n        self.assert_(dict.fromkeys(self.logical_disks))\n    def test_equalable(self):\n        \"Ensure instances compare equal\"\n        self.assertEqual(self.logical_disks, self.logical_disks)\n    def test_not_equal_to_anything_else(self):\n        \"Ensure WMI instances are not equal to non-WMI instances\"\n        for d in self.logical_disks:",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstanceCreation",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestInstanceCreation(TestWMI):\n    def test_create_instance(self):\n        self.assert_(isinstance(self.connection.Win32_ProcessStartup.new(ShowWindow=2), wmi._wmi_object))\nclass TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestAssociations",
        "kind": 6,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "class TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #\n        for q in self.connection.Win32_DiskQuota():\n            for p in q.properties:\n                try:",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "ini",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "ini = ConfigParser.SafeConfigParser()\nini.read([\"wmitest.master.ini\", \"wmitest.ini\"])\nsettings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "settings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "excludes",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "excludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "COMPUTERS",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "COMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "IMPERSONATION_LEVELS",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "IMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHENTICATION_LEVELS",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "AUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHORITIES",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "AUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "PRIVILEGES",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "PRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmitest",
        "description": "todo_project.env.Scripts.wmitest",
        "peekOfCode": "NAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:",
        "detail": "todo_project.env.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "link",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "start_doc",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"\n    <html>\n    <head>\n    <title>%(title)s</title>\n    <style>\n    body {font-family : Verdana, sans-serif; font-size : 84%%; margin : 3em;}\n    table.items {padding-left : 30px;}\n    li, td {font-family : \"Courier New\", monospace;}",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "finish_doc",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def finish_doc():\n    doc.append(\"\"\"\n    </body>\n    </html>\n    \"\"\" % locals())\ndef doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_table",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")\n        for n_col in range(n_cols):\n            item = items[n_cols * n_col + n_row]\n            if callback:\n                item = callback(item)\n            doc.append(\"<td><li>%s</li></td>\" % item)",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_breadcrumbs",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def doc_breadcrumbs(computer, namespace, wmi_class=None):\n    doc.append('<p class=\"breadcrumbs\">')\n    doc.append('%s &rarr; %s' % (link(computer, computer), link(namespace, computer, namespace)))\n    if wmi_class:\n        doc.append(' &rarr; %s' % (link(wmi_class, computer, namespace, wmi_class)))\n    doc.append('</p>')\ndef doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_wmi_class",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())\n    klass = getattr(wmi_connection, wmi_class)\n    def property_callback(property_name):\n        property = klass.wmi_property(property_name)\n        mapping = property.qualifiers.get(\"MappingStrings\")\n        if mapping is None:\n            return property_name",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_namespace",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def doc_namespace(computer, namespace, wmi_connection):\n    start_doc(\"WMI: Namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace)\n    namespaces = namespace.split(\"\\\\\")\n    namespace_links = []\n    for i, n in enumerate(namespaces):\n        namespace_links.append(link(n, computer, \"\\\\\".join(namespaces[:i+1])))\n    doc.append(\"<h2>%s</h2>\" % \"\\\\\".join(namespace_links))\n    doc.append(\"<hr>\")\n    subnamespaces = sorted(wmi_connection.__NAMESPACE())",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_namespace",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def handle_namespace(environ, computer, namespace):\n    if not namespace:\n        wmi_connection = wmi.WMI(computer, namespace=\"root/cimv2\")\n        for setting in wmi_connection.Win32_WMISetting():\n            namespace=setting.ASPScriptDefaultNamespace\n            break\n    wmi_connection = wmi.WMI(computer, namespace=namespace, find_classes=True)\n    wmi_class = shift_path_info(environ)\n    if wmi_class:\n        doc_wmi_class(computer, namespace, wmi_class, wmi_connection)",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_computer",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def handle_computer(environ, computer):\n    handle_namespace(environ, computer, shift_path_info(environ))\ndef app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)\n        return(unicode(d).encode(\"utf8\") + unicode(\"\\n\").encode(\"utf8\") for d in doc)\n    else:",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_browser",
        "kind": 2,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "def run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print(\"Shutting down gracefully...\")",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "doc = []\ndef link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "todo_project.env.Scripts.wmiweb",
        "description": "todo_project.env.Scripts.wmiweb",
        "peekOfCode": "PORT = 8010\ndef run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:",
        "detail": "todo_project.env.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "AI",
        "kind": 6,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "peekOfCode": "class AI:\n    def __init__(self, model=\"gpt-4\", temperature=0.1):\n        self.temperature = temperature\n        self.model = model\n    def start(self, system, user):\n        messages = [\n            {\"role\": \"system\", \"content\": system},\n            {\"role\": \"user\", \"content\": user},\n        ]\n        return self.next(messages)",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "fallback_model",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "peekOfCode": "def fallback_model(model: str) -> str:\n    try:\n        openai.Model.retrieve(model)\n        return model\n    except openai.InvalidRequestError:\n        print(\n            f\"Model {model} not available for provided API key. Reverting \"\n            \"to gpt-3.5-turbo. Sign up for the GPT-4 wait list here: \"\n            \"https://openai.com/waitlist/gpt-4-api\\n\"\n        )",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass AI:\n    def __init__(self, model=\"gpt-4\", temperature=0.1):\n        self.temperature = temperature\n        self.model = model\n    def start(self, system, user):\n        messages = [\n            {\"role\": \"system\", \"content\": system},\n            {\"role\": \"user\", \"content\": user},\n        ]",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.ai",
        "documentation": {}
    },
    {
        "label": "parse_chat",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.chat_to_files",
        "peekOfCode": "def parse_chat(chat):  # -> List[Tuple[str, str]]:\n    # Get all ``` blocks and preceding filenames\n    regex = r\"(\\S+)\\n\\s*```[^\\n]*\\n(.+?)```\"\n    matches = re.finditer(regex, chat, re.DOTALL)\n    files = []\n    for match in matches:\n        # Strip the filename of any non-allowed characters and convert / to \\\n        path = re.sub(r'[<>\"|?*]', \"\", match.group(1))\n        # Remove leading and trailing brackets\n        path = re.sub(r\"^\\[(.*)\\]$\", r\"\\1\", path)",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.chat_to_files",
        "documentation": {}
    },
    {
        "label": "to_files",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.chat_to_files",
        "peekOfCode": "def to_files(chat, workspace):\n    workspace[\"all_output.txt\"] = chat\n    files = parse_chat(chat)\n    for file_name, file_content in files:\n        workspace[file_name] = file_content",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.chat_to_files",
        "documentation": {}
    },
    {
        "label": "send_learning",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "peekOfCode": "def send_learning(learning: Learning):\n    import rudderstack.analytics as rudder_analytics\n    rudder_analytics.write_key = \"2Re4kqwL61GDp7S8ewe6K5dbogG\"\n    rudder_analytics.dataPlaneUrl = \"https://gptengineerezm.dataplane.rudderstack.com\"\n    rudder_analytics.track(\n        user_id=learning.session,\n        event=\"learning\",\n        properties=learning.to_dict(),  # type: ignore\n    )\ndef collect_learnings(model: str, temperature: float, steps: List[Step], dbs: DBs):",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "documentation": {}
    },
    {
        "label": "collect_learnings",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "peekOfCode": "def collect_learnings(model: str, temperature: float, steps: List[Step], dbs: DBs):\n    if os.environ.get(\"COLLECT_LEARNINGS_OPT_IN\") in [\"false\", \"1\"]:\n        print(\"COLLECT_LEARNINGS_OPT_IN is set to false, not collecting learning\")\n        return\n    learnings = extract_learning(\n        model, temperature, steps, dbs, steps_file_hash=steps_file_hash()\n    )\n    send_learning(learnings)\ndef steps_file_hash():\n    with open(steps.__file__, \"r\") as f:",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "documentation": {}
    },
    {
        "label": "steps_file_hash",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "peekOfCode": "def steps_file_hash():\n    with open(steps.__file__, \"r\") as f:\n        content = f.read()\n        return hashlib.sha256(content.encode(\"utf-8\"), usedforsecurity=False).hexdigest()",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.collect",
        "documentation": {}
    },
    {
        "label": "DB",
        "kind": 6,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.db",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.db",
        "peekOfCode": "class DB:\n    \"\"\"A simple key-value store, where keys are filenames and values are file contents.\"\"\"\n    def __init__(self, path):\n        self.path = Path(path).absolute()\n        self.path.mkdir(parents=True, exist_ok=True)\n    def __contains__(self, key):\n        return (self.path / key).is_file()\n    def __getitem__(self, key):\n        full_path = self.path / key\n        if not full_path.is_file():",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "DBs",
        "kind": 6,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.db",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.db",
        "peekOfCode": "class DBs:\n    memory: DB\n    logs: DB\n    preprompts: DB\n    input: DB\n    workspace: DB",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.db",
        "documentation": {}
    },
    {
        "label": "Step",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.domain",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.domain",
        "peekOfCode": "Step = TypeVar(\"Step\", bound=Callable[[AI, DBs], List[dict]])",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.domain",
        "documentation": {}
    },
    {
        "label": "Review",
        "kind": 6,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "class Review:\n    ran: Optional[bool]\n    perfect: Optional[bool]\n    works: Optional[bool]\n    comments: str\n    raw: str\n@dataclass_json\n@dataclass\nclass Learning:\n    model: str",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "Learning",
        "kind": 6,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "class Learning:\n    model: str\n    temperature: float\n    steps: str\n    steps_file_hash: str\n    prompt: str\n    logs: str\n    workspace: str\n    feedback: Optional[str]\n    session: str",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "human_input",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "def human_input() -> Review:\n    print()\n    print(\n        colored(\"To help gpt-engineer learn, please answer 3 questions:\", \"light_green\")\n    )\n    print()\n    ran = input(\"Did the generated code run at all? \" + TERM_CHOICES)\n    while ran not in (\"y\", \"n\", \"u\"):\n        ran = input(\"Invalid input. Please enter y, n, or u: \")\n    perfect = \"\"",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "logs_to_string",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "def logs_to_string(steps: List[Step], logs: DB):\n    chunks = []\n    for step in steps:\n        chunks.append(f\"--- {step.__name__} ---\\n\")\n        messages = json.loads(logs[step.__name__])\n        chunks.append(format_messages(messages))\n    return \"\\n\".join(chunks)\ndef format_messages(messages: List[dict]) -> str:\n    return \"\\n\".join(\n        [f\"{message['role']}:\\n\\n{message['content']}\" for message in messages]",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "format_messages",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "def format_messages(messages: List[dict]) -> str:\n    return \"\\n\".join(\n        [f\"{message['role']}:\\n\\n{message['content']}\" for message in messages]\n    )\ndef extract_learning(\n    model: str, temperature: float, steps: List[Step], dbs: DBs, steps_file_hash\n) -> Learning:\n    review = None\n    if \"review\" in dbs.memory:\n        review = Review.from_json(dbs.memory[\"review\"])  # type: ignore",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "extract_learning",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "def extract_learning(\n    model: str, temperature: float, steps: List[Step], dbs: DBs, steps_file_hash\n) -> Learning:\n    review = None\n    if \"review\" in dbs.memory:\n        review = Review.from_json(dbs.memory[\"review\"])  # type: ignore\n    learning = Learning(\n        prompt=dbs.input[\"prompt\"],\n        model=model,\n        temperature=temperature,",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "get_session",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "def get_session():\n    path = Path(tempfile.gettempdir()) / \"gpt_engineer_user_id.txt\"\n    try:\n        if path.exists():\n            user_id = path.read_text()\n        else:\n            # random uuid:\n            user_id = str(random.randint(0, 2**32))\n            path.write_text(user_id)\n        return user_id",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "TERM_CHOICES",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "peekOfCode": "TERM_CHOICES = (\n    colored(\"y\", \"green\")\n    + \"/\"\n    + colored(\"n\", \"red\")\n    + \"/\"\n    + colored(\"u\", \"yellow\")\n    + \"(ncertain): \"\n)\ndef human_input() -> Review:\n    print()",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.learning",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.main",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.main",
        "peekOfCode": "def main(\n    project_path: str = typer.Argument(\"example\", help=\"path\"),\n    delete_existing: bool = typer.Argument(False, help=\"delete existing files\"),\n    model: str = typer.Argument(\"gpt-4\", help=\"model id string\"),\n    temperature: float = 0.1,\n    steps_config: steps.Config = typer.Option(\n        steps.Config.DEFAULT, \"--steps\", \"-s\", help=\"decide which steps to run\"\n    ),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\"),\n    run_prefix: str = typer.Option(",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.main",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.main",
        "peekOfCode": "app = typer.Typer()\n@app.command()\ndef main(\n    project_path: str = typer.Argument(\"example\", help=\"path\"),\n    delete_existing: bool = typer.Argument(False, help=\"delete existing files\"),\n    model: str = typer.Argument(\"gpt-4\", help=\"model id string\"),\n    temperature: float = 0.1,\n    steps_config: steps.Config = typer.Option(\n        steps.Config.DEFAULT, \"--steps\", \"-s\", help=\"decide which steps to run\"\n    ),",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.main",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "class Config(str, Enum):\n    DEFAULT = \"default\"\n    BENCHMARK = \"benchmark\"\n    SIMPLE = \"simple\"\n    TDD = \"tdd\"\n    TDD_PLUS = \"tdd+\"\n    CLARIFY = \"clarify\"\n    RESPEC = \"respec\"\n    EXECUTE_ONLY = \"execute_only\"\n    EVALUATE = \"evaluate\"",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "setup_sys_prompt",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def setup_sys_prompt(dbs: DBs) -> str:\n    return (\n        dbs.preprompts[\"generate\"] + \"\\nUseful to know:\\n\" + dbs.preprompts[\"philosophy\"]\n    )\ndef get_prompt(dbs: DBs) -> str:\n    \"\"\"While we migrate we have this fallback getter\"\"\"\n    assert (\n        \"prompt\" in dbs.input or \"main_prompt\" in dbs.input\n    ), \"Please put your prompt in the file `prompt` in the project directory\"\n    if \"prompt\" not in dbs.input:",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "get_prompt",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def get_prompt(dbs: DBs) -> str:\n    \"\"\"While we migrate we have this fallback getter\"\"\"\n    assert (\n        \"prompt\" in dbs.input or \"main_prompt\" in dbs.input\n    ), \"Please put your prompt in the file `prompt` in the project directory\"\n    if \"prompt\" not in dbs.input:\n        print(\n            colored(\"Please put the prompt in the file `prompt`, not `main_prompt\", \"red\")\n        )\n        print()",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "simple_gen",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def simple_gen(ai: AI, dbs: DBs) -> List[dict]:\n    \"\"\"Run the AI on the main prompt and save the results\"\"\"\n    messages = ai.start(setup_sys_prompt(dbs), get_prompt(dbs))\n    to_files(messages[-1][\"content\"], dbs.workspace)\n    return messages\ndef clarify(ai: AI, dbs: DBs) -> List[dict]:\n    \"\"\"\n    Ask the user if they want to clarify anything and save the results to the workspace\n    \"\"\"\n    messages = [ai.fsystem(dbs.preprompts[\"qa\"])]",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "clarify",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def clarify(ai: AI, dbs: DBs) -> List[dict]:\n    \"\"\"\n    Ask the user if they want to clarify anything and save the results to the workspace\n    \"\"\"\n    messages = [ai.fsystem(dbs.preprompts[\"qa\"])]\n    user_input = get_prompt(dbs)\n    while True:\n        messages = ai.next(messages, user_input)\n        if messages[-1][\"content\"].strip() == \"Nothing more to clarify.\":\n            break",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "gen_spec",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def gen_spec(ai: AI, dbs: DBs) -> List[dict]:\n    \"\"\"\n    Generate a spec from the main prompt + clarifications and save the results to\n    the workspace\n    \"\"\"\n    messages = [\n        ai.fsystem(setup_sys_prompt(dbs)),\n        ai.fsystem(f\"Instructions: {dbs.input['prompt']}\"),\n    ]\n    messages = ai.next(messages, dbs.preprompts[\"spec\"])",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "respec",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def respec(ai: AI, dbs: DBs) -> List[dict]:\n    messages = json.loads(dbs.logs[gen_spec.__name__])\n    messages += [ai.fsystem(dbs.preprompts[\"respec\"])]\n    messages = ai.next(messages)\n    messages = ai.next(\n        messages,\n        (\n            \"Based on the conversation so far, please reiterate the specification for \"\n            \"the program. \"\n            \"If there are things that can be improved, please incorporate the \"",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "gen_unit_tests",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def gen_unit_tests(ai: AI, dbs: DBs) -> List[dict]:\n    \"\"\"\n    Generate unit tests based on the specification, that should work.\n    \"\"\"\n    messages = [\n        ai.fsystem(setup_sys_prompt(dbs)),\n        ai.fuser(f\"Instructions: {dbs.input['prompt']}\"),\n        ai.fuser(f\"Specification:\\n\\n{dbs.memory['specification']}\"),\n    ]\n    messages = ai.next(messages, dbs.preprompts[\"unit_tests\"])",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "gen_clarified_code",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def gen_clarified_code(ai: AI, dbs: DBs) -> List[dict]:\n    \"\"\"Takes clarification and generates code\"\"\"\n    messages = json.loads(dbs.logs[clarify.__name__])\n    messages = [\n        ai.fsystem(setup_sys_prompt(dbs)),\n    ] + messages[1:]\n    messages = ai.next(messages, dbs.preprompts[\"use_qa\"])\n    to_files(messages[-1][\"content\"], dbs.workspace)\n    return messages\ndef gen_code(ai: AI, dbs: DBs) -> List[dict]:",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "gen_code",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def gen_code(ai: AI, dbs: DBs) -> List[dict]:\n    # get the messages from previous step\n    messages = [\n        ai.fsystem(setup_sys_prompt(dbs)),\n        ai.fuser(f\"Instructions: {dbs.input['prompt']}\"),\n        ai.fuser(f\"Specification:\\n\\n{dbs.memory['specification']}\"),\n        ai.fuser(f\"Unit tests:\\n\\n{dbs.memory['unit_tests']}\"),\n    ]\n    messages = ai.next(messages, dbs.preprompts[\"use_qa\"])\n    to_files(messages[-1][\"content\"], dbs.workspace)",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "execute_entrypoint",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def execute_entrypoint(ai: AI, dbs: DBs) -> List[dict]:\n    command = dbs.workspace[\"run.sh\"]\n    print(\"Do you want to execute this code?\")\n    print()\n    print(command)\n    print()\n    print('If yes, press enter. Otherwise, type \"no\"')\n    print()\n    if input() not in [\"\", \"y\", \"yes\"]:\n        print(\"Ok, not executing the code.\")",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "gen_entrypoint",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def gen_entrypoint(ai: AI, dbs: DBs) -> List[dict]:\n    messages = ai.start(\n        system=(\n            \"You will get information about a codebase that is currently on disk in \"\n            \"the current folder.\\n\"\n            \"From this you will answer with code blocks that includes all the necessary \"\n            \"unix terminal commands to \"\n            \"a) install dependencies \"\n            \"b) run all necessary parts of the codebase (in parallel if necessary).\\n\"\n            \"Do not install globally. Do not use sudo.\\n\"",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "use_feedback",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def use_feedback(ai: AI, dbs: DBs):\n    messages = [\n        ai.fsystem(setup_sys_prompt(dbs)),\n        ai.fuser(f\"Instructions: {dbs.input['prompt']}\"),\n        ai.fassistant(dbs.workspace[\"all_output.txt\"]),\n        ai.fsystem(dbs.preprompts[\"use_feedback\"]),\n    ]\n    messages = ai.next(messages, dbs.input[\"feedback\"])\n    to_files(messages[-1][\"content\"], dbs.workspace)\n    return messages",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "fix_code",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def fix_code(ai: AI, dbs: DBs):\n    code_output = json.loads(dbs.logs[gen_code.__name__])[-1][\"content\"]\n    messages = [\n        ai.fsystem(setup_sys_prompt(dbs)),\n        ai.fuser(f\"Instructions: {dbs.input['prompt']}\"),\n        ai.fuser(code_output),\n        ai.fsystem(dbs.preprompts[\"fix_code\"]),\n    ]\n    messages = ai.next(messages, \"Please fix any errors in the code above.\")\n    to_files(messages[-1][\"content\"], dbs.workspace)",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "human_review",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "def human_review(ai: AI, dbs: DBs):\n    review = human_input()\n    dbs.memory[\"review\"] = review.to_json()  # type: ignore\n    return []\nclass Config(str, Enum):\n    DEFAULT = \"default\"\n    BENCHMARK = \"benchmark\"\n    SIMPLE = \"simple\"\n    TDD = \"tdd\"\n    TDD_PLUS = \"tdd+\"",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "STEPS",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "description": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "peekOfCode": "STEPS = {\n    Config.DEFAULT: [\n        clarify,\n        gen_clarified_code,\n        gen_entrypoint,\n        execute_entrypoint,\n        human_review,\n    ],\n    Config.BENCHMARK: [simple_gen, gen_entrypoint],\n    Config.SIMPLE: [simple_gen, gen_entrypoint, execute_entrypoint],",
        "detail": "todo_project.env.src.gpt-engineer.gpt_engineer.steps",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.benchmark",
        "description": "todo_project.env.src.gpt-engineer.scripts.benchmark",
        "peekOfCode": "def main(\n    n_benchmarks: Union[int, None] = None,\n):\n    path = Path(\"benchmark\")\n    folders: Iterable[Path] = path.iterdir()\n    if n_benchmarks:\n        folders = islice(folders, n_benchmarks)\n    benchmarks = []\n    for bench_folder in folders:\n        if os.path.isdir(bench_folder):",
        "detail": "todo_project.env.src.gpt-engineer.scripts.benchmark",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.clean_benchmarks",
        "description": "todo_project.env.src.gpt-engineer.scripts.clean_benchmarks",
        "peekOfCode": "def main():\n    benchmarks = Path(\"benchmark\")\n    for benchmark in benchmarks.iterdir():\n        if benchmark.is_dir():\n            print(f\"Cleaning {benchmark}\")\n            for path in benchmark.iterdir():\n                if path.name in [\"prompt\", \"main_prompt\"]:\n                    continue\n                # Get filename of Path object\n                if path.is_dir():",
        "detail": "todo_project.env.src.gpt-engineer.scripts.clean_benchmarks",
        "documentation": {}
    },
    {
        "label": "pretty_print_conversation",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "description": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "peekOfCode": "def pretty_print_conversation(messages):\n    role_to_color = {\n        \"system\": \"red\",\n        \"user\": \"green\",\n        \"assistant\": \"blue\",\n        \"function\": \"magenta\",\n    }\n    formatted_messages = []\n    for message in messages:\n        if message[\"role\"] == \"function\":",
        "detail": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "description": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "peekOfCode": "def main(\n    messages_path: str,\n):\n    with open(messages_path) as f:\n        messages = json.load(f)\n    pretty_print_conversation(messages)\nif __name__ == \"__main__\":\n    app()",
        "detail": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "description": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "peekOfCode": "app = typer.Typer()\ndef pretty_print_conversation(messages):\n    role_to_color = {\n        \"system\": \"red\",\n        \"user\": \"green\",\n        \"assistant\": \"blue\",\n        \"function\": \"magenta\",\n    }\n    formatted_messages = []\n    for message in messages:",
        "detail": "todo_project.env.src.gpt-engineer.scripts.print_chat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.rerun_edited_message_logs",
        "description": "todo_project.env.src.gpt-engineer.scripts.rerun_edited_message_logs",
        "peekOfCode": "def main(\n    messages_path: str,\n    out_path: Union[str, None] = None,\n    model: str = \"gpt-4\",\n    temperature: float = 0.1,\n):\n    ai = AI(\n        model=model,\n        temperature=temperature,\n    )",
        "detail": "todo_project.env.src.gpt-engineer.scripts.rerun_edited_message_logs",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "todo_project.env.src.gpt-engineer.scripts.rerun_edited_message_logs",
        "description": "todo_project.env.src.gpt-engineer.scripts.rerun_edited_message_logs",
        "peekOfCode": "app = typer.Typer()\n@app.command()\ndef main(\n    messages_path: str,\n    out_path: Union[str, None] = None,\n    model: str = \"gpt-4\",\n    temperature: float = 0.1,\n):\n    ai = AI(\n        model=model,",
        "detail": "todo_project.env.src.gpt-engineer.scripts.rerun_edited_message_logs",
        "documentation": {}
    },
    {
        "label": "test_ai",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_ai",
        "description": "todo_project.env.src.gpt-engineer.tests.test_ai",
        "peekOfCode": "def test_ai():\n    AI()\n    # TODO Assert that methods behave and not only constructor.",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_ai",
        "documentation": {}
    },
    {
        "label": "test_to_files",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_to_files():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    file1.py\n    ```python\n    print(\"Hello, World!\")\n    ```\n    file2.py\n    ```python",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_to_files_with_square_brackets",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_to_files_with_square_brackets():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    [file1.py]\n    ```python\n    print(\"Hello, World!\")\n    ```\n    [file2.py]\n    ```python",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_files_with_brackets_in_name",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_files_with_brackets_in_name():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    [id].jsx\n    ```javascript\n    console.log(\"Hello, World!\")\n    ```\n    \"\"\"\n    )",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_files_with_file_colon",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_files_with_file_colon():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    [FILE: file1.py]\n    ```python\n    print(\"Hello, World!\")\n    ```\n    \"\"\"\n    )",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_files_with_back_tick",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_files_with_back_tick():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    `file1.py`\n    ```python\n    print(\"Hello, World!\")\n    ```\n    \"\"\"\n    )",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_files_with_newline_between",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_files_with_newline_between():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    file1.py\n    ```python\n    print(\"Hello, World!\")\n    ```\n    \"\"\"\n    )",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_files_with_newline_between_header",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "description": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "peekOfCode": "def test_files_with_newline_between_header():\n    chat = textwrap.dedent(\n        \"\"\"\n    This is a sample program.\n    ## file1.py\n    ```python\n    print(\"Hello, World!\")\n    ```\n    \"\"\"\n    )",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_chat_to_files",
        "documentation": {}
    },
    {
        "label": "test_collect_learnings",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_collect",
        "description": "todo_project.env.src.gpt-engineer.tests.test_collect",
        "peekOfCode": "def test_collect_learnings(monkeypatch):\n    monkeypatch.setattr(os, \"environ\", {\"COLLECT_LEARNINGS_OPT_IN\": \"true\"})\n    monkeypatch.setattr(rudder_analytics, \"track\", MagicMock())\n    model = \"test_model\"\n    temperature = 0.5\n    steps = [gen_code]\n    dbs = DBs(DB(\"/tmp\"), DB(\"/tmp\"), DB(\"/tmp\"), DB(\"/tmp\"), DB(\"/tmp\"))\n    dbs.input = {\n        \"prompt\": \"test prompt\\n with newlines\",\n        \"feedback\": \"test feedback\",",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_collect",
        "documentation": {}
    },
    {
        "label": "test_DB_operations",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_DB_operations(tmp_path):\n    # Test initialization\n    db = DB(tmp_path)\n    # Test __setitem__\n    db[\"test_key\"] = \"test_value\"\n    assert (tmp_path / \"test_key\").is_file()\n    # Test __getitem__\n    val = db[\"test_key\"]\n    assert val == \"test_value\"\n    # Test error on getting non-existent key",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_DBs_initialization",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_DBs_initialization(tmp_path):\n    dir_names = [\"memory\", \"logs\", \"preprompts\", \"input\", \"workspace\"]\n    directories = [tmp_path / name for name in dir_names]\n    # Create DB objects\n    dbs = [DB(dir) for dir in directories]\n    # Create DB instance\n    dbs_instance = DBs(*dbs)\n    assert isinstance(dbs_instance.memory, DB)\n    assert isinstance(dbs_instance.logs, DB)\n    assert isinstance(dbs_instance.preprompts, DB)",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_invalid_path",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_invalid_path():\n    with pytest.raises((PermissionError, OSError)):\n        # Test with a path that will raise a permission error\n        DB(\"/root/test\")\ndef test_large_files(tmp_path):\n    db = DB(tmp_path)\n    large_content = \"a\" * (10**6)  # 1MB of data\n    # Test write large files\n    db[\"large_file\"] = large_content\n    # Test read large files",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_large_files",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_large_files(tmp_path):\n    db = DB(tmp_path)\n    large_content = \"a\" * (10**6)  # 1MB of data\n    # Test write large files\n    db[\"large_file\"] = large_content\n    # Test read large files\n    assert db[\"large_file\"] == large_content\ndef test_concurrent_access(tmp_path):\n    import threading\n    db = DB(tmp_path)",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_concurrent_access",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_concurrent_access(tmp_path):\n    import threading\n    db = DB(tmp_path)\n    num_threads = 10\n    num_writes = 1000\n    def write_to_db(thread_id):\n        for i in range(num_writes):\n            key = f\"thread{thread_id}_write{i}\"\n            db[key] = str(i)\n    threads = []",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_error_messages",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_error_messages(tmp_path):\n    db = DB(tmp_path)\n    with pytest.raises(TypeError) as e:\n        db[\"key\"] = [\"Invalid\", \"value\"]\n    assert str(e.value) == \"val must be either a str or bytes\"\ndef test_DBs_instantiation_with_wrong_number_of_arguments(tmp_path):\n    db = DB(tmp_path)\n    with pytest.raises(TypeError):\n        DBs(db, db, db)\n    with pytest.raises(TypeError):",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_DBs_instantiation_with_wrong_number_of_arguments",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_DBs_instantiation_with_wrong_number_of_arguments(tmp_path):\n    db = DB(tmp_path)\n    with pytest.raises(TypeError):\n        DBs(db, db, db)\n    with pytest.raises(TypeError):\n        DBs(db, db, db, db, db, db)\ndef test_DBs_dataclass_attributes(tmp_path):\n    dir_names = [\"memory\", \"logs\", \"preprompts\", \"input\", \"workspace\"]\n    directories = [tmp_path / name for name in dir_names]\n    # Create DB objects",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "test_DBs_dataclass_attributes",
        "kind": 2,
        "importPath": "todo_project.env.src.gpt-engineer.tests.test_db",
        "description": "todo_project.env.src.gpt-engineer.tests.test_db",
        "peekOfCode": "def test_DBs_dataclass_attributes(tmp_path):\n    dir_names = [\"memory\", \"logs\", \"preprompts\", \"input\", \"workspace\"]\n    directories = [tmp_path / name for name in dir_names]\n    # Create DB objects\n    dbs = [DB(dir) for dir in directories]\n    # Create DBs instance\n    dbs_instance = DBs(*dbs)\n    assert dbs_instance.memory == dbs[0]\n    assert dbs_instance.logs == dbs[1]\n    assert dbs_instance.preprompts == dbs[2]",
        "detail": "todo_project.env.src.gpt-engineer.tests.test_db",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "todo_project.todo_app.migrations.0001_initial",
        "description": "todo_project.todo_app.migrations.0001_initial",
        "peekOfCode": "class Migration(migrations.Migration):\n    initial = True\n    dependencies = []\n    operations = [\n        migrations.CreateModel(\n            name=\"Task\",\n            fields=[\n                (\n                    \"id\",\n                    models.BigAutoField(",
        "detail": "todo_project.todo_app.migrations.0001_initial",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "todo_project.todo_app.migrations.0002_task_updated_at",
        "description": "todo_project.todo_app.migrations.0002_task_updated_at",
        "peekOfCode": "class Migration(migrations.Migration):\n    dependencies = [\n        (\"todo_app\", \"0001_initial\"),\n    ]\n    operations = [\n        migrations.AddField(\n            model_name=\"task\",\n            name=\"updated_at\",\n            field=models.DateTimeField(auto_now=True),\n        ),",
        "detail": "todo_project.todo_app.migrations.0002_task_updated_at",
        "documentation": {}
    },
    {
        "label": "TodoAppConfig",
        "kind": 6,
        "importPath": "todo_project.todo_app.apps",
        "description": "todo_project.todo_app.apps",
        "peekOfCode": "class TodoAppConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"todo_app\"",
        "detail": "todo_project.todo_app.apps",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "todo_project.todo_app.models",
        "description": "todo_project.todo_app.models",
        "peekOfCode": "class Task(models.Model):\n    title = models.CharField(max_length=200)\n    completed = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)",
        "detail": "todo_project.todo_app.models",
        "documentation": {}
    },
    {
        "label": "task_manager",
        "kind": 2,
        "importPath": "todo_project.todo_app.views",
        "description": "todo_project.todo_app.views",
        "peekOfCode": "def task_manager(request):\n    tasks = Task.objects.all()\n    edit_task = None\n    if request.method == 'POST':\n        if 'edit_task_id' in request.POST:\n            edit_task = get_object_or_404(Task, pk=request.POST['edit_task_id'])\n            edit_task.title = request.POST['title']\n            edit_task.save()\n            return redirect('task_manager')\n        else:",
        "detail": "todo_project.todo_app.views",
        "documentation": {}
    },
    {
        "label": "mark_complete",
        "kind": 2,
        "importPath": "todo_project.todo_app.views",
        "description": "todo_project.todo_app.views",
        "peekOfCode": "def mark_complete(request, task_id):\n    task = get_object_or_404(Task, pk=task_id)\n    task.completed = True\n    task.save()\n    return redirect('task_manager')\ndef edit_task(request, task_id):\n    edit_task = get_object_or_404(Task, pk=task_id)\n    if request.method == 'POST':\n        edit_task.title = request.POST['title']\n        edit_task.save()",
        "detail": "todo_project.todo_app.views",
        "documentation": {}
    },
    {
        "label": "edit_task",
        "kind": 2,
        "importPath": "todo_project.todo_app.views",
        "description": "todo_project.todo_app.views",
        "peekOfCode": "def edit_task(request, task_id):\n    edit_task = get_object_or_404(Task, pk=task_id)\n    if request.method == 'POST':\n        edit_task.title = request.POST['title']\n        edit_task.save()\n        return redirect('task_manager')\n    tasks = Task.objects.all()\n    return render(request, 'todo_app/task_manager.html', {'tasks': tasks, 'edit_task': edit_task, 'edit_mode': True})\ndef delete_task(request, task_id):\n    task = get_object_or_404(Task, pk=task_id)",
        "detail": "todo_project.todo_app.views",
        "documentation": {}
    },
    {
        "label": "delete_task",
        "kind": 2,
        "importPath": "todo_project.todo_app.views",
        "description": "todo_project.todo_app.views",
        "peekOfCode": "def delete_task(request, task_id):\n    task = get_object_or_404(Task, pk=task_id)\n    task.delete()\n    return redirect('task_manager')",
        "detail": "todo_project.todo_app.views",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "todo_project.todo_project.asgi",
        "description": "todo_project.todo_project.asgi",
        "peekOfCode": "application = get_asgi_application()",
        "detail": "todo_project.todo_project.asgi",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent.parent\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = \"django-insecure-rf6i3h!#pj=o9sce$$c@vpwxyxwrwecae(#7$wehw0t-eq(m!o\"\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "SECRET_KEY = \"django-insecure-rf6i3h!#pj=o9sce$$c@vpwxyxwrwecae(#7$wehw0t-eq(m!o\"\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "DEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "ALLOWED_HOSTS",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "ALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    'todo_app',",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "INSTALLED_APPS",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "INSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    'todo_app',\n]\nMIDDLEWARE = [",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "MIDDLEWARE",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "MIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]\nROOT_URLCONF = \"todo_project.urls\"",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "ROOT_URLCONF",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "ROOT_URLCONF = \"todo_project.urls\"\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "TEMPLATES",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "TEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "WSGI_APPLICATION",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "WSGI_APPLICATION = \"todo_project.wsgi.application\"\n# Database\n# https://docs.djangoproject.com/en/4.2/ref/settings/#databases\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'todo_app',\n        'USER': 'root',\n        'PASSWORD': '2236541',\n        'HOST': 'localhost',",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "DATABASES",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'todo_app',\n        'USER': 'root',\n        'PASSWORD': '2236541',\n        'HOST': 'localhost',\n        'PORT': '3306',\n    }\n}",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "\"\"\"DATABASES",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "\"\"\"DATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n    }\n}\"\"\"\n# Password validation\n# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "AUTH_PASSWORD_VALIDATORS",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "AUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "LANGUAGE_CODE = \"en-us\"\nTIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nimport os\nSTATIC_URL = \"static/\"\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'todo_app/static'),",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "TIME_ZONE",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "TIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nimport os\nSTATIC_URL = \"static/\"\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'todo_app/static'),\n]",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "USE_I18N",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "USE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nimport os\nSTATIC_URL = \"static/\"\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'todo_app/static'),\n]\n# Default primary key field type",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "USE_TZ",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "USE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nimport os\nSTATIC_URL = \"static/\"\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'todo_app/static'),\n]\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "STATIC_URL",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "STATIC_URL = \"static/\"\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'todo_app/static'),\n]\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "STATICFILES_DIRS",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "STATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'todo_app/static'),\n]\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_AUTO_FIELD",
        "kind": 5,
        "importPath": "todo_project.todo_project.settings",
        "description": "todo_project.todo_project.settings",
        "peekOfCode": "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "todo_project.todo_project.settings",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "todo_project.todo_project.urls",
        "description": "todo_project.todo_project.urls",
        "peekOfCode": "urlpatterns = [\n    path('', views.task_manager, name='task_manager'),\n    path('add/', views.task_manager, name='add_task'),\n    path('complete/<int:task_id>/', views.mark_complete, name='mark_complete'),\n    path('edit/<int:task_id>/', views.edit_task, name='edit_task'),\n    path('delete/<int:task_id>/', views.delete_task, name='delete_task'),\n]",
        "detail": "todo_project.todo_project.urls",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "todo_project.todo_project.wsgi",
        "description": "todo_project.todo_project.wsgi",
        "peekOfCode": "application = get_wsgi_application()",
        "detail": "todo_project.todo_project.wsgi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "todo_project.manage",
        "description": "todo_project.manage",
        "peekOfCode": "def main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"todo_project.settings\")\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"",
        "detail": "todo_project.manage",
        "documentation": {}
    }
]